



From Wikipedia, the free encyclopedia


Process by which software is developed






|  | This article **needs additional citations for [verification](/wiki/Wikipedia:Verifiability "Wikipedia:Verifiability")**. Please help [improve this article](/wiki/Special:EditPage/Software_development_process "Special:EditPage/Software development process") by [adding citations to reliable sources](/wiki/Help:Referencing_for_beginners "Help:Referencing for beginners"). Unsourced material may be challenged and removed.*Find sources:* ["Software development process"](https://www.google.com/search?as_eq=wikipedia&q=%22Software+development+process%22) – [news](https://www.google.com/search?tbm=nws&q=%22Software+development+process%22+-wikipedia&tbs=ar:1) **·** [newspapers](https://www.google.com/search?&q=%22Software+development+process%22&tbs=bkt:s&tbm=bks) **·** [books](https://www.google.com/search?tbs=bks:1&q=%22Software+development+process%22+-wikipedia) **·** [scholar](https://scholar.google.com/scholar?q=%22Software+development+process%22) **·** [JSTOR](https://www.jstor.org/action/doBasicSearch?Query=%22Software+development+process%22&acc=on&wc=on) *(December 2010)* *([Learn how and when to remove this message](/wiki/Help:Maintenance_template_removal "Help:Maintenance template removal"))* |
| --- | --- |








| Part of a series on |
| --- |
| [Software development](/wiki/Software_development "Software development") |
| Core activities * [Data modeling](/wiki/Data_modeling "Data modeling") * Processes * [Requirements](/wiki/Requirements_analysis "Requirements analysis") * [Design](/wiki/Software_design "Software design") * [Construction](/wiki/Software_construction "Software construction") * [Engineering](/wiki/Software_engineering "Software engineering") * [Testing](/wiki/Software_testing "Software testing") * [Debugging](/wiki/Debugging "Debugging") * [Deployment](/wiki/Software_deployment "Software deployment") * [Maintenance](/wiki/Software_maintenance "Software maintenance") |
| Paradigms and models * [Agile](/wiki/Agile_software_development "Agile software development") * [Cleanroom](/wiki/Cleanroom_software_engineering "Cleanroom software engineering") * [Incremental](/wiki/Incremental_build_model "Incremental build model") * [Prototyping](/wiki/Software_prototyping "Software prototyping") * [Spiral](/wiki/Spiral_model "Spiral model") * [V model](/wiki/V-model_(software_development) "V-model (software development)") * [Waterfall](/wiki/Waterfall_model "Waterfall model") |
| [Methodologies](/wiki/Software_development_methodology "Software development methodology") and frameworks * [ASD](/wiki/Adaptive_software_development "Adaptive software development") * [DevOps](/wiki/DevOps "DevOps") * [DAD](/wiki/Disciplined_agile_delivery "Disciplined agile delivery") * [DSDM](/wiki/Dynamic_systems_development_method "Dynamic systems development method") * [FDD](/wiki/Feature-driven_development "Feature-driven development") * [IID](/wiki/Iterative_and_incremental_development "Iterative and incremental development") * [Kanban](/wiki/Kanban_(development) "Kanban (development)") * [Lean SD](/wiki/Lean_software_development "Lean software development") * [LeSS](/wiki/Scrum_(software_development)#Large-scale_Scrum "Scrum (software development)") * [MDD](/wiki/Model-driven_development "Model-driven development") * [MSF](/wiki/Microsoft_Solutions_Framework "Microsoft Solutions Framework") * [PSP](/wiki/Personal_software_process "Personal software process") * [RAD](/wiki/Rapid_application_development "Rapid application development") * [RUP](/wiki/Rational_Unified_Process "Rational Unified Process") * [SAFe](/wiki/Scaled_agile_framework "Scaled agile framework") * [Scrum](/wiki/Scrum_(software_development) "Scrum (software development)") * [SEMAT](/wiki/SEMAT "SEMAT") * [TDD](/wiki/Test-driven_development "Test-driven development") * [TSP](/wiki/Team_software_process "Team software process") * [OpenUP](/wiki/OpenUP "OpenUP") * [UP](/wiki/Unified_Process "Unified Process") * [XP](/wiki/Extreme_programming "Extreme programming") |
| Supporting disciplines * [Configuration management](/wiki/Software_configuration_management "Software configuration management") * [Documentation](/wiki/Software_documentation "Software documentation") * [Software quality assurance](/wiki/Software_quality_assurance "Software quality assurance") * [Project management](/wiki/Software_project_management "Software project management") * [User experience](/wiki/User_experience "User experience") |
| Practices * [ATDD](/wiki/Acceptance_test%E2%80%93driven_development "Acceptance test–driven development") * [BDD](/wiki/Behavior-driven_development "Behavior-driven development") * [CCO](/wiki/Extreme_programming_practices#Collective_code_ownership "Extreme programming practices") * [CI](/wiki/Continuous_integration "Continuous integration") * [CD](/wiki/Continuous_delivery "Continuous delivery") * [DDD](/wiki/Domain-driven_design "Domain-driven design") * [PP](/wiki/Pair_programming "Pair programming") * [SBE](/wiki/Specification_by_example "Specification by example") * [Stand-up](/wiki/Stand-up_meeting "Stand-up meeting") * [TDD](/wiki/Test-driven_development "Test-driven development") |
| [Tools](/wiki/Programming_tool "Programming tool") * [Compiler](/wiki/Compiler "Compiler") * [Debugger](/wiki/Debugger "Debugger") * [Profiler](/wiki/Profiling_(computer_programming) "Profiling (computer programming)") * [GUI designer](/wiki/Graphical_user_interface_builder "Graphical user interface builder") * [UML Modeling](/wiki/UML_tool "UML tool") * [IDE](/wiki/Integrated_development_environment "Integrated development environment") * [Build automation](/wiki/Build_automation "Build automation") * [Release automation](/wiki/Application-release_automation "Application-release automation") * [Infrastructure as code](/wiki/Infrastructure_as_code "Infrastructure as code") |
| Standards and bodies of knowledge * [CMMI](/wiki/Capability_Maturity_Model_Integration "Capability Maturity Model Integration") * [IEEE standards](/wiki/IEEE_Standards_Association "IEEE Standards Association") * [ISO 9001](/wiki/ISO_9001 "ISO 9001") * [ISO/IEC standards](/wiki/ISO/IEC_JTC_1/SC_7 "ISO/IEC JTC 1/SC 7") * [PMBOK](/wiki/Project_Management_Body_of_Knowledge "Project Management Body of Knowledge") * [SWEBOK](/wiki/Software_Engineering_Body_of_Knowledge "Software Engineering Body of Knowledge") * [ITIL](/wiki/ITIL "ITIL") * [IREB](/wiki/International_Requirements_Engineering_Board "International Requirements Engineering Board") * [OMG](/wiki/Object_Management_Group "Object Management Group") |
| Glossaries * [Artificial intelligence](/wiki/Glossary_of_artificial_intelligence "Glossary of artificial intelligence") * [Computer science](/wiki/Glossary_of_computer_science "Glossary of computer science") * [Electrical and electronics engineering](/wiki/Glossary_of_electrical_and_electronics_engineering "Glossary of electrical and electronics engineering") |
| Outlines * [Outline of software development](/wiki/Outline_of_software_development "Outline of software development") |
| * [v](/wiki/Template:Software_development_process "Template:Software development process") * [t](/wiki/Template_talk:Software_development_process "Template talk:Software development process") * [e](/wiki/Special:EditPage/Template:Software_development_process "Special:EditPage/Template:Software development process") |


In [software engineering](/wiki/Software_engineering "Software engineering"), a **software development process** or **software development life cycle** (**SDLC**) is a process of planning and managing [software development](/wiki/Software_development "Software development"). It typically involves dividing software development work into smaller, parallel, or sequential steps or sub-processes to improve [design](/wiki/Software_design "Software design") and/or [product management](/wiki/Software_product_management "Software product management"). The methodology may include the pre-definition of specific [deliverables](/wiki/Deliverable "Deliverable") and artifacts that are created and completed by a project team to develop or maintain an application.[[1]](#cite_note-CMS08-1)


Most modern development processes can be vaguely described as [agile](/wiki/Agile_software_development "Agile software development"). Other methodologies include [waterfall](/wiki/Waterfall_model "Waterfall model"), [prototyping](/wiki/Software_prototyping "Software prototyping"), [iterative and incremental development](/wiki/Iterative_and_incremental_development "Iterative and incremental development"), [spiral development](/wiki/Spiral_development "Spiral development"), [rapid application development](/wiki/Rapid_application_development "Rapid application development"), and [extreme programming](/wiki/Extreme_programming "Extreme programming").


A life-cycle "model" is sometimes considered a more general term for a category of methodologies and a software development "process" is a particular instance as adopted by a specific organization. [*[citation needed](/wiki/Wikipedia:Citation_needed "Wikipedia:Citation needed")*] For example, many specific software development processes fit the spiral life-cycle model. The field is often considered a subset of the [systems development life cycle](/wiki/Systems_development_life_cycle "Systems development life cycle").




History[[edit](/w/index.php?title=Software_development_process&action=edit&section=1 "Edit section: History")]
--------------------------------------------------------------------------------------------------------------


The software development methodology (also known as SDM) framework didn't emerge until the 1960s. According to Elliott (2004), the [systems development life cycle](/wiki/Systems_development_life_cycle "Systems development life cycle") (SDLC) can be considered to be the oldest formalized methodology framework for building [information systems](/wiki/Information_system "Information system"). The main idea of the SDLC has been "to pursue the development of information systems in a very deliberate, structured and methodical way, requiring each stage of the life cycle––from the inception of the idea to delivery of the final system––to be carried out rigidly and sequentially"[[2]](#cite_note-Ell04-2) within the context of the framework being applied. The main target of this methodology framework in the 1960s was "to develop large scale functional [business systems](/wiki/Business_system "Business system") in an age of large scale business conglomerates. Information systems activities revolved around heavy [data processing](/wiki/Data_processing "Data processing") and [number crunching](/wiki/Number_crunching "Number crunching") routines."[[2]](#cite_note-Ell04-2)


**Requirements gathering and analysis:**
The first phase of the custom software development process involves understanding the client's requirements and objectives. This stage typically involves engaging in thorough discussions and conducting interviews with stakeholders to identify the desired features, functionalities, and overall scope of the software. The development team works closely with the client to analyze existing systems and workflows, determine technical feasibility, and define project milestones.


**Planning and design:**
Once the requirements are understood, the custom software development team proceeds to create a comprehensive project plan. This plan outlines the development roadmap, including timelines, resource allocation, and deliverables. The software architecture and design are also established during this phase. User interface (UI) and user experience (UX) design elements are considered to ensure the software's usability, intuitiveness, and visual appeal.


**Development:**
With the planning and design in place, the development team begins the coding process. This phase involves [writing](/wiki/Writing "Writing"), testing, and debugging the software code. Agile methodologies, such as scrum or kanban, are often employed to promote flexibility, collaboration, and iterative development. Regular communication between the development team and the client ensures transparency and enables quick feedback and adjustments.


**Testing and quality assurance:**
To ensure the software's reliability, performance, and security, rigorous testing and quality assurance (QA) processes are carried out. Different testing techniques, including unit testing, integration testing, system testing, and user acceptance testing, are employed to identify and rectify any issues or bugs. QA activities aim to validate the software against the predefined requirements, ensuring that it functions as intended.


**Deployment and implementation:**
Once the software passes the testing phase, it is ready for deployment and implementation. The development team assists the client in setting up the software environment, migrating data if necessary, and configuring the system. User training and documentation are also provided to ensure a smooth transition and enable users to maximize the software's potential.


**Maintenance and support:**
After the software is deployed, ongoing maintenance and support become crucial to address any issues, enhance performance, and incorporate future enhancements. Regular updates, bug fixes, and security patches are released to keep the software up-to-date and secure. This phase also involves providing technical support to end users and addressing their queries or concerns.
Methodologies, processes, and frameworks range from specific prescriptive steps that can be used directly by an organization in day-to-day work, to flexible frameworks that an organization uses to generate a custom set of steps tailored to the needs of a specific project or group. In some cases, a "sponsor" or "maintenance" organization distributes an official set of documents that describe the process. Specific examples include:



1970s
* [Structured programming](/wiki/Structured_programming "Structured programming") since 1969
* [Cap Gemini SDM](/wiki/Cap_Gemini_SDM "Cap Gemini SDM"), originally from PANDATA, the first English translation was published in 1974. SDM stands for System Development Methodology


1980s
* [Structured systems analysis and design method](/wiki/Structured_systems_analysis_and_design_method "Structured systems analysis and design method") (SSADM) from 1980 onwards
* [Information Requirement Analysis/Soft systems methodology](/wiki/Soft_systems_methodology "Soft systems methodology")


1990s
* [Object-oriented programming](/wiki/Object-oriented_programming "Object-oriented programming") (OOP) developed in the early 1960s and became a dominant programming approach during the mid-1990s
* [Rapid application development](/wiki/Rapid_application_development "Rapid application development") (RAD), since 1991
* [Dynamic systems development method](/wiki/Dynamic_systems_development_method "Dynamic systems development method") (DSDM), since 1994
* [Scrum](/wiki/Scrum_(software_development) "Scrum (software development)"), since 1995
* [Team software process](/wiki/Team_software_process "Team software process"), since 1998
* [Rational Unified Process](/wiki/Rational_Unified_Process "Rational Unified Process") (RUP), maintained by IBM since 1998
* [Extreme programming](/wiki/Extreme_programming "Extreme programming"), since 1999


2000s
* [Agile Unified Process](/wiki/Agile_Unified_Process "Agile Unified Process") (AUP) maintained since 2005 by [Scott Ambler](/wiki/Scott_Ambler "Scott Ambler")
* [Disciplined agile delivery](/wiki/Disciplined_agile_delivery "Disciplined agile delivery") (DAD) Supersedes AUP


2010s
* [Scaled Agile Framework](/wiki/Scaled_Agile_Framework "Scaled Agile Framework") (SAFe)
* [Large-Scale Scrum](/wiki/Large-Scale_Scrum "Large-Scale Scrum") (LeSS)
* [DevOps](/wiki/DevOps "DevOps")


Since DSDM in 1994, all of the methodologies on the above list except RUP have been agile methodologies - yet many organizations, especially governments, still use pre-agile processes (often waterfall or similar). Software process and [software quality](/wiki/Software_quality "Software quality") are closely interrelated; some unexpected facets and effects have been observed in practice.[[3]](#cite_note-ieeesw-3)


Among these, another software development process has been established in [open source](/wiki/Open-source_software "Open-source software"). The adoption of these best practices known and established processes within the confines of a company is called [inner source](/wiki/Inner_source "Inner source").



Prototyping[[edit](/w/index.php?title=Software_development_process&action=edit&section=2 "Edit section: Prototyping")]
----------------------------------------------------------------------------------------------------------------------


[Software prototyping](/wiki/Software_prototyping "Software prototyping") is about creating prototypes, i.e. incomplete versions of the software program being developed.


The basic principles are:[[1]](#cite_note-CMS08-1)



* Prototyping is not a standalone, complete development methodology, but rather an approach to try out particular features in the context of a full methodology (such as incremental, spiral, or rapid application development (RAD)).
* Attempts to reduce inherent project risk by breaking a project into smaller segments and providing more ease of change during the development process.
* The client is involved throughout the development process, which increases the likelihood of client acceptance of the final implementation.
* While some prototypes are developed with the expectation that they will be discarded, it is possible in some cases to evolve from prototype to working system.


A basic understanding of the fundamental business problem is necessary to avoid solving the wrong problems, but this is true for all software methodologies.



Methodologies[[edit](/w/index.php?title=Software_development_process&action=edit&section=3 "Edit section: Methodologies")]
--------------------------------------------------------------------------------------------------------------------------


### Agile development[[edit](/w/index.php?title=Software_development_process&action=edit&section=4 "Edit section: Agile development")]


Main article: [Agile software development](/wiki/Agile_software_development "Agile software development")
"Agile software development" refers to a group of software development frameworks based on iterative development, where requirements and solutions evolve via collaboration between self-organizing cross-functional teams. The term was coined in the year 2001 when the [Agile Manifesto](/wiki/Agile_Manifesto "Agile Manifesto") was formulated.


Agile software development uses iterative development as a basis but advocates a lighter and more people-centric viewpoint than traditional approaches. Agile processes fundamentally incorporate iteration and the continuous feedback that it provides to successively refine and deliver a software system.


The Agile model also includes the following software development processes:



* [Dynamic systems development method](/wiki/Dynamic_systems_development_method "Dynamic systems development method") (DSDM)
* [Kanban](/wiki/Kanban_(development) "Kanban (development)")
* [Scrum](/wiki/Scrum_(development) "Scrum (development)")
* Crystal
* Atern
* [Lean software development](/wiki/Lean_software_development "Lean software development")


### Continuous integration[[edit](/w/index.php?title=Software_development_process&action=edit&section=5 "Edit section: Continuous integration")]


Main article: [Continuous integration](/wiki/Continuous_integration "Continuous integration")
[Continuous integration](/wiki/Continuous_integration "Continuous integration") is the practice of merging all developer working copies to a shared [mainline](/wiki/Trunk_(software) "Trunk (software)") several times a day.[[4]](#cite_note-CI0-4)
[Grady Booch](/wiki/Grady_Booch "Grady Booch") first named and proposed CI in [his 1991 method](/wiki/Booch_method "Booch method"),[[5]](#cite_note-5) although he did not advocate integrating several times a day. [Extreme programming](/wiki/Extreme_programming "Extreme programming") (XP) adopted the concept of CI and did advocate integrating more than once per day – perhaps as many as tens of times per day.



### Incremental development[[edit](/w/index.php?title=Software_development_process&action=edit&section=6 "Edit section: Incremental development")]


Main article: [Iterative and incremental development](/wiki/Iterative_and_incremental_development "Iterative and incremental development")
Various methods are acceptable for combining linear and iterative systems development methodologies, with the primary objective of each being to reduce inherent project risk by breaking a project into smaller segments and providing more ease-of-change during the development process.


There are three main variants of incremental development:[[1]](#cite_note-CMS08-1)



1. A series of mini-waterfalls are performed, where all phases of the waterfall are completed for a small part of a system, before proceeding to the next increment, or
2. Overall requirements are defined before proceeding to evolutionary, mini-waterfall development of individual increments of a system, or
3. The initial software concept, requirements analysis, and design of architecture and system core are defined via waterfall, followed by incremental implementation, which culminates in installing the final version, a working system.


### Rapid application development[[edit](/w/index.php?title=Software_development_process&action=edit&section=7 "Edit section: Rapid application development")]


Main article: [Rapid application development](/wiki/Rapid_application_development "Rapid application development")
[![](//upload.wikimedia.org/wikipedia/commons/thumb/5/5f/RADModel.JPG/220px-RADModel.JPG)](/wiki/File:RADModel.JPG)

Rapid Application Development (RAD) Model


[Rapid application development](/wiki/Rapid_application_development "Rapid application development") (RAD) is a software development methodology, which favors [iterative development](/wiki/Iterative_development "Iterative development") and the rapid construction of [prototypes](/wiki/Prototype "Prototype") instead of large amounts of up-front planning. The "planning" of software developed using RAD is interleaved with writing the software itself. The lack of extensive pre-planning generally allows software to be written much faster and makes it easier to change requirements.


The rapid development process starts with the development of preliminary [data models](/wiki/Data_model "Data model") and [business process models](/wiki/Business_process_model "Business process model") using [structured techniques](/wiki/Structured_technique "Structured technique"). In the next stage, requirements are verified using prototyping, eventually to refine the data and process models. These stages are repeated iteratively; further development results in "a combined business requirements and technical design statement to be used for constructing new systems".[[6]](#cite_note-WBD04-6)


The term was first used to describe a software development process introduced by [James Martin](/wiki/James_Martin_(author) "James Martin (author)") in 1991. According to Whitten (2003), it is a merger of various [structured techniques](/wiki/Structured_Analysis_and_Design_Technique "Structured Analysis and Design Technique"), especially data-driven [information technology engineering](/wiki/Information_technology_engineering "Information technology engineering"), with prototyping techniques to accelerate software systems development.[[6]](#cite_note-WBD04-6)


The basic principles of rapid application development are:[[1]](#cite_note-CMS08-1)



* Key objective is for fast development and delivery of a high-quality system at a relatively low investment cost.
* Attempts to reduce inherent project risk by breaking a project into smaller segments and providing more ease of change during the development process.
* Aims to produce high-quality systems quickly, primarily via iterative Prototyping (at any stage of development), active user involvement, and computerized development tools. These tools may include [Graphical User Interface](/wiki/Graphical_User_Interface "Graphical User Interface") (GUI) builders, [Computer Aided Software Engineering](/wiki/Computer_Aided_Software_Engineering "Computer Aided Software Engineering") (CASE) tools, [Database Management Systems](/wiki/Database_Management_System "Database Management System") (DBMS), [fourth-generation programming languages](/wiki/Fourth-generation_programming_language "Fourth-generation programming language"), code generators, and object-oriented techniques.
* Key emphasis is on fulfilling the business need, while technological or engineering excellence is of lesser importance.
* Project control involves prioritizing development and defining delivery deadlines or “timeboxes”. If the project starts to slip, the emphasis is on reducing requirements to fit the timebox, not on increasing the deadline.
* Generally includes [joint application design](/wiki/Joint_application_design "Joint application design") (JAD), where users are intensely involved in [system design](/wiki/System_design "System design"), via consensus building in either structured workshops, or electronically facilitated interaction.
* Active user involvement is imperative.
* Iteratively produces production software, as opposed to a throwaway prototype.
* Produces documentation necessary to facilitate future development and maintenance.
* Standard systems analysis and design methods can be fitted into this framework.


### Waterfall development[[edit](/w/index.php?title=Software_development_process&action=edit&section=8 "Edit section: Waterfall development")]


Main article: [Waterfall model](/wiki/Waterfall_model "Waterfall model")
[![](//upload.wikimedia.org/wikipedia/commons/thumb/e/e2/Waterfall_model.svg/220px-Waterfall_model.svg.png)](/wiki/File:Waterfall_model.svg)

The activities of the software development process represented in the [waterfall model](/wiki/Waterfall_model "Waterfall model"). There are several other models to represent this process.


The waterfall model is a sequential development approach, in which development is seen as flowing steadily downwards (like a waterfall) through several phases, typically:



* [Requirements analysis](/wiki/Requirements_analysis "Requirements analysis") resulting in a [software requirements specification](/wiki/Software_requirements_specification "Software requirements specification")
* [Software design](/wiki/Software_design "Software design")
* [Implementation](/wiki/Computer_programming "Computer programming")
* [Testing](/wiki/Software_testing "Software testing")
* [Integration](/wiki/System_integration "System integration"), if there are multiple subsystems
* [Deployment](/wiki/Software_deployment "Software deployment") (or [Installation](/wiki/Installation_(computer_programs) "Installation (computer programs)"))
* [Maintenance](/wiki/Software_maintenance "Software maintenance")


The first formal description of the method is often cited as an article published by [Winston W. Royce](/wiki/Winston_W._Royce "Winston W. Royce")[[7]](#cite_note-7) in 1970, although Royce did not use the term "waterfall" in this article. Royce presented this model as an example of a flawed, non-working model.[[8]](#cite_note-8)


The basic principles are:[[1]](#cite_note-CMS08-1)



* The Project is divided into sequential phases, with some overlap and splashback acceptable between phases.
* Emphasis is on planning, time schedules, target dates, budgets, and implementation of an entire system at one time.
* Tight control is maintained over the life of the project via extensive written documentation, formal reviews, and approval/signoff by the user and [information technology management](/wiki/Information_technology_management "Information technology management") occurring at the end of most phases before beginning the next phase. Written documentation is an explicit deliverable of each phase.


The waterfall model is a traditional engineering approach applied to software engineering. A strict waterfall approach discourages revisiting and revising any prior phase once it is complete. [*[according to whom?](/wiki/Wikipedia:Manual_of_Style/Words_to_watch#Unsupported_attributions "Wikipedia:Manual of Style/Words to watch")*] This "inflexibility" in a pure waterfall model has been a source of criticism by supporters of other more "flexible" models. It has been widely blamed for several large-scale government projects running over budget, over time and sometimes failing to deliver on requirements due to the [big design up front](/wiki/Big_design_up_front "Big design up front") approach.[*[according to whom?](/wiki/Wikipedia:Manual_of_Style/Words_to_watch#Unsupported_attributions "Wikipedia:Manual of Style/Words to watch")*] Except when contractually required, the waterfall model has been largely superseded by more flexible and versatile methodologies developed specifically for software development.[*[according to whom?](/wiki/Wikipedia:Manual_of_Style/Words_to_watch#Unsupported_attributions "Wikipedia:Manual of Style/Words to watch")*] See [Criticism of waterfall model](/wiki/Waterfall_model#Criticism "Waterfall model").



### Spiral development[[edit](/w/index.php?title=Software_development_process&action=edit&section=9 "Edit section: Spiral development")]


[![](//upload.wikimedia.org/wikipedia/commons/thumb/e/ec/Spiral_model_%28Boehm%2C_1988%29.svg/400px-Spiral_model_%28Boehm%2C_1988%29.svg.png)](/wiki/File:Spiral_model_(Boehm,_1988).svg)

Spiral model (Boehm, 1988)


Main article: [Spiral model](/wiki/Spiral_model "Spiral model")
In 1988, [Barry Boehm](/wiki/Barry_Boehm "Barry Boehm") published a formal software system development "spiral model," which combines some key aspects of the [waterfall model](/wiki/Waterfall_model "Waterfall model") and [rapid prototyping](/wiki/Rapid_application_development "Rapid application development") methodologies, in an effort to combine advantages of [top-down and bottom-up](/wiki/Top-down_and_bottom-up_design "Top-down and bottom-up design") concepts. It provided emphasis on a key area many felt had been neglected by other methodologies: deliberate iterative risk analysis, particularly suited to large-scale complex systems.


The basic principles are:[[1]](#cite_note-CMS08-1)



* Focus is on risk assessment and on minimizing project risk by breaking a project into smaller segments and providing more ease-of-change during the development process, as well as providing the opportunity to evaluate risks and weigh consideration of project continuation throughout the life cycle.
* "Each cycle involves a progression through the same sequence of steps, for each part of the product and for each of its levels of elaboration, from an overall concept-of-operation document down to the coding of each individual program."[[9]](#cite_note-BB86-9)
* Each trip around the spiral traverses four basic quadrants: (1) determine objectives, alternatives, and constraints of the iteration, and (2) evaluate alternatives; Identify and resolve risks; (3) develop and verify deliverables from the iteration; and (4) plan the next iteration.[[10]](#cite_note-RT-BB86-10)
* Begin each cycle with an identification of stakeholders and their "win conditions", and end each cycle with review and commitment.[[11]](#cite_note-11)


### Shape Up[[edit](/w/index.php?title=Software_development_process&action=edit&section=10 "Edit section: Shape Up")]


Shape Up is a software development approach introduced by [Basecamp](/wiki/Basecamp_(company) "Basecamp (company)") in 2018. It is a set of principles and techniques that Basecamp developed internally to overcome the problem of projects dragging on with no clear end. Its primary target audience is remote teams. Shape Up has no estimation and velocity tracking, backlogs, or sprints, unlike [waterfall](/wiki/Waterfall_model "Waterfall model"), [agile](/wiki/Agile_software_development "Agile software development"), or [scrum](/wiki/Scrum_(software_development) "Scrum (software development)"). Instead, those concepts are replaced with appetite, betting, and cycles. As of 2022, besides Basecamp, notable organizations that have adopted Shape Up include UserVoice and Block.[[12]](#cite_note-12)[[13]](#cite_note-13)



### Advanced methodologies[[edit](/w/index.php?title=Software_development_process&action=edit&section=11 "Edit section: Advanced methodologies")]


Other high-level software project methodologies include:



* [Behavior-driven development](/wiki/Behavior-driven_development "Behavior-driven development") and business process management.[[14]](#cite_note-ieeeswbdd-14)
* [Chaos model](/wiki/Chaos_model "Chaos model") - The main rule always resolves the most important issue first.
* [Incremental funding methodology](/wiki/Incremental_funding_methodology "Incremental funding methodology") - an iterative approach
* [Lightweight methodology](/wiki/Lightweight_methodology "Lightweight methodology") - a general term for methods that only have a few rules and practices
* [Structured systems analysis and design method](/wiki/Structured_systems_analysis_and_design_method "Structured systems analysis and design method") - a specific version of waterfall
* Slow programming, as part of the larger [Slow Movement](/wiki/Slow_movement_(culture) "Slow movement (culture)"), emphasizes careful and gradual work without (or minimal) time pressures. Slow programming aims to avoid bugs and overly quick release schedules.
* [V-Model (software development)](/wiki/V-Model_(software_development) "V-Model (software development)") - an extension of the waterfall model
* [Unified Process](/wiki/Unified_Process "Unified Process") (UP) is an iterative software development methodology framework, based on [Unified Modeling Language](/wiki/Unified_Modeling_Language "Unified Modeling Language") (UML). UP organizes the development of software into four phases, each consisting of one or more executable iterations of the software at that stage of development: inception, elaboration, construction, and guidelines. Many tools and products exist to facilitate UP implementation. One of the more popular versions of UP is the [Rational Unified Process](/wiki/Rational_Unified_Process "Rational Unified Process") (RUP).
* Big Bang methodology - an approach for small or undefined projects, generally consisting of little to no planning with high risk.


Process meta-models[[edit](/w/index.php?title=Software_development_process&action=edit&section=12 "Edit section: Process meta-models")]
---------------------------------------------------------------------------------------------------------------------------------------


Some "[process models](/wiki/Process_model "Process model")" are abstract descriptions for evaluating, comparing, and improving the specific process adopted by an organization.



* [ISO/IEC 12207](/wiki/ISO/IEC_12207 "ISO/IEC 12207") is the international standard describing the method to select, implement, and monitor the life cycle for software.
* The [Capability Maturity Model Integration](/wiki/Capability_Maturity_Model_Integration "Capability Maturity Model Integration") (CMMI) is one of the leading models and is based on best practices. Independent assessments grade organizations on how well they follow their defined processes, not on the quality of those processes or the software produced. CMMI has replaced [CMM](/wiki/Capability_Maturity_Model "Capability Maturity Model").
* [ISO 9000](/wiki/ISO_9000 "ISO 9000") describes standards for a formally organized process to manufacture a product and the methods of managing and monitoring progress. Although the standard was originally created for the manufacturing sector, ISO 9000 standards have been applied to software development as well. Like CMMI, certification with ISO 9000 does not guarantee the quality of the end result, only that formalized business processes have been followed.
* [ISO/IEC 15504](/wiki/ISO/IEC_15504 "ISO/IEC 15504") *Information technology—Process assessment is* also known as Software Process Improvement Capability Determination (SPICE), is a "framework for the assessment of software processes". This standard is aimed at setting out a clear model for process comparison. SPICE is used much like CMMI. It models processes to manage, control, guide, and monitor software development. This model is then used to measure what a development organization or project team actually does during software development. This information is analyzed to identify weaknesses and drive improvement. It also identifies strengths that can be continued or integrated into common practice for that organization or team.
* [ISO/IEC 24744](/wiki/ISO/IEC_24744 "ISO/IEC 24744") *Software Engineering—Metamodel for Development Methodologies*, is a power type-based metamodel for software development methodologies.
* SPEM 2.0 by the Object Management Group.
* [Soft systems methodology](/wiki/Soft_systems_methodology "Soft systems methodology") - a general method for improving management processes.
* [Method engineering](/wiki/Method_engineering "Method engineering") - a general method for improving information system processes.


Further information: [Process patterns](/wiki/Process_patterns "Process patterns")
In practice[[edit](/w/index.php?title=Software_development_process&action=edit&section=13 "Edit section: In practice")]
-----------------------------------------------------------------------------------------------------------------------


[![](//upload.wikimedia.org/wikipedia/commons/thumb/5/5f/Three_software_development_patterns_mashed_together.svg/420px-Three_software_development_patterns_mashed_together.svg.png)](/wiki/File:Three_software_development_patterns_mashed_together.svg)

The three basic approaches applied to software development methodology frameworks


A variety of such frameworks have evolved over the years, each with its own recognized strengths and weaknesses. One software development methodology framework is not necessarily suitable for use by all projects. Each of the available methodology frameworks is best suited to specific kinds of projects, based on various technical, organizational, project, and team considerations.[[1]](#cite_note-CMS08-1)


[Software development](/wiki/Software_development "Software development") organizations implement process methodologies to ease the process of development. Sometimes, contractors may require methodologies employed, an example is the U.S. [defense industry](/wiki/Arms_industry "Arms industry"), which requires a rating based on [process models](/wiki/Process_model "Process model") to obtain contracts. The international standard for describing the method of selecting, implementing, and monitoring the life cycle for software is [ISO/IEC 12207](/wiki/ISO/IEC_12207 "ISO/IEC 12207").


A decades-long goal has been to find repeatable, predictable processes that improve productivity and quality. Some try to systematize or formalize the seemingly unruly task of designing software. Others apply [project management](/wiki/Project_management "Project management") techniques to designing software. Large numbers of software projects do not meet their expectations in terms of functionality, cost, or delivery schedule - see [List of failed and overbudget custom software projects](/wiki/List_of_failed_and_overbudget_custom_software_projects "List of failed and overbudget custom software projects") for some notable examples.


Organizations may create a [Software Engineering Process Group](/wiki/Software_Engineering_Process_Group "Software Engineering Process Group") (SEPG), which is the focal point for process improvement. Composed of line practitioners who have varied skills, the group is at the center of the collaborative effort of everyone in the organization who is involved with software engineering process improvement.


A particular development team may also agree to program environment details, such as which [integrated development environment](/wiki/Integrated_development_environment "Integrated development environment") is used one or more dominant [programming paradigms](/wiki/Programming_paradigm "Programming paradigm"), [programming style](/wiki/Programming_style "Programming style") rules, or choice of specific [software libraries](/wiki/Software_libraries "Software libraries") or [software frameworks](/wiki/Software_framework "Software framework"). These details are generally not dictated by the choice of model or general methodology.


In today's digital world, it is critical to prioritize security throughout the software development life cycle (SDLC). Malicious actors are continually looking for holes to exploit; therefore, cyber security dangers are on the rise. Organizations may protect sensitive data, prevent breaches, and maintain user trust by incorporating security measures at each stage of development. This proactive strategy not only reduces risks but also assures regulatory compliance, resulting in a more resilient and secure digital ecosystem.



See also[[edit](/w/index.php?title=Software_development_process&action=edit&section=14 "Edit section: See also")]
-----------------------------------------------------------------------------------------------------------------


* [Systems development life cycle](/wiki/Systems_development_life_cycle "Systems development life cycle")
* [Computer-aided software engineering](/wiki/Computer-aided_software_engineering "Computer-aided software engineering") (some of these tools support specific methodologies)
* [List of software development philosophies](/wiki/List_of_software_development_philosophies "List of software development philosophies")
* [Outline of software engineering](/wiki/Outline_of_software_engineering "Outline of software engineering")
* [OpenUP](/wiki/OpenUP "OpenUP")
* [Software Project Management](/wiki/Software_project_management "Software project management")
* [Software development](/wiki/Software_development "Software development")
* [Software development effort estimation](/wiki/Software_development_effort_estimation "Software development effort estimation")
* [Software release life cycle](/wiki/Software_release_life_cycle "Software release life cycle")
* [Top-down and bottom-up design#Computer science](/wiki/Top-down_and_bottom-up_design#Computer_science "Top-down and bottom-up design")


References[[edit](/w/index.php?title=Software_development_process&action=edit&section=15 "Edit section: References")]
---------------------------------------------------------------------------------------------------------------------



1. ^ [***a***](#cite_ref-CMS08_1-0) [***b***](#cite_ref-CMS08_1-1) [***c***](#cite_ref-CMS08_1-2) [***d***](#cite_ref-CMS08_1-3) [***e***](#cite_ref-CMS08_1-4) [***f***](#cite_ref-CMS08_1-5) [***g***](#cite_ref-CMS08_1-6) ["Selecting a development approach"](https://web.archive.org/web/20120620212919/http://www.cms.gov/Research-Statistics-Data-and-Systems/CMS-Information-Technology/XLC/Downloads/SelectingDevelopmentApproach.pdf) (PDF). *Centers for Medicare & Medicaid Services (CMS) Office of Information Service*. United States Department of Health and Human Services (HHS). March 27, 2008 [Original Issuance: February 17, 2005]. Archived from [the original](http://www.cms.gov/Research-Statistics-Data-and-Systems/CMS-Information-Technology/XLC/Downloads/SelectingDevelopmentApproach.pdf) (PDF) on June 20, 2012. Retrieved October 27, 2008.
2. ^ [***a***](#cite_ref-Ell04_2-0) [***b***](#cite_ref-Ell04_2-1) Geoffrey Elliott (2004). *Global Business Information Technology: an integrated systems approach*. Pearson Education. p. 87.
3. **[^](#cite_ref-ieeesw_3-0)** Suryanarayana, Girish (2015). ["Software Process versus Design Quality: Tug of War?"](https://doi.org/10.1109%2FMS.2015.87). *IEEE Software*. **32** (4): 7–11. [doi](/wiki/Doi_(identifier) "Doi (identifier)"):[10.1109/MS.2015.87](https://doi.org/10.1109%2FMS.2015.87).
4. **[^](#cite_ref-CI0_4-0)** Paul M. Duvall; Steve Matyas; [Andrew Glover](/wiki/Andrew_Glover "Andrew Glover") (2007). [*Continuous Integration: Improving Software Quality and Reducing Risk*](https://www.amazon.com/Continuous-Integration-Improving-Software-Reducing/dp/0321336380). [Addison-Wesley Professional](/wiki/Addison-Wesley_Professional "Addison-Wesley Professional"). [ISBN](/wiki/ISBN_(identifier) "ISBN (identifier)") [978-0-321-33638-5](/wiki/Special:BookSources/978-0-321-33638-5 "Special:BookSources/978-0-321-33638-5").
5. **[^](#cite_ref-5)** [Booch, Grady](/wiki/Grady_Booch "Grady Booch") (1991). [*Object Oriented Design: With Applications*](https://books.google.com/books?id=w5VQAAAAMAAJ&q=continuous+integration+inauthor:grady+inauthor:booch). [Benjamin Cummings](/wiki/Benjamin_Cummings "Benjamin Cummings"). p. 209. [ISBN](/wiki/ISBN_(identifier) "ISBN (identifier)") [9780805300918](/wiki/Special:BookSources/9780805300918 "Special:BookSources/9780805300918"). Retrieved August 18, 2014.
6. ^ [***a***](#cite_ref-WBD04_6-0) [***b***](#cite_ref-WBD04_6-1) [Whitten, Jeffrey L.](/wiki/Whitten,_Jeffrey_L. "Whitten, Jeffrey L."); [Lonnie D. Bentley](/wiki/Lonnie_D._Bentley "Lonnie D. Bentley"), [Kevin C. Dittman](/wiki/Kevin_C._Dittman "Kevin C. Dittman"). (2003). *Systems Analysis and Design Methods*. 6th edition. [ISBN](/wiki/ISBN_(identifier) "ISBN (identifier)") [0-256-19906-X](/wiki/Special:BookSources/0-256-19906-X "Special:BookSources/0-256-19906-X").
7. **[^](#cite_ref-7)** Markus Rerych. ["Wasserfallmodell > Entstehungskontext"](http://cartoon.iguw.tuwien.ac.at/fit/fit01/wasserfall/entstehung.html). *Institut für Gestaltungs- und Wirkungsforschung, TU-Wien* (in German). Retrieved November 28, 2007.
8. **[^](#cite_ref-8)** Conrad Weisert. ["Waterfall methodology: there's no such thing!"](https://web.archive.org/web/20220802131155/http://www.idinews.com/waterfall.html). Archived from [the original](http://www.idinews.com/waterfall.html) on August 2, 2022.
9. **[^](#cite_ref-BB86_9-0)** [Barry Boehm](/wiki/Barry_Boehm "Barry Boehm") (August 1986). ["A Spiral Model of Software Development and Enhancement"](http://doi.acm.org/10.1145/12944.12948). *ACM SIGSOFT Software Engineering Notes*. **11** (4). [Association for Computing Machinery](/wiki/Association_for_Computing_Machinery "Association for Computing Machinery"): 14–24. [doi](/wiki/Doi_(identifier) "Doi (identifier)"):[10.1145/12944.12948](https://doi.org/10.1145%2F12944.12948). [S2CID](/wiki/S2CID_(identifier) "S2CID (identifier)") [1781829](https://api.semanticscholar.org/CorpusID:1781829).
10. **[^](#cite_ref-RT-BB86_10-0)** Richard H. Thayer; [Barry W. Boehm](/wiki/Barry_Boehm "Barry Boehm") (1986). *Tutorial: software engineering project management*. Computer Society Press of the IEEE. p. 130.
11. **[^](#cite_ref-11)** [Barry W. Boehm](/wiki/Barry_Boehm "Barry Boehm") (2000). *Software cost estimation with Cocomo II: Volume 1*.
12. **[^](#cite_ref-12)** ["Foreword by Jason Fried | Shape Up"](https://basecamp.com/shapeup/0.1-foreword). *basecamp.com*. Retrieved September 11, 2022.
13. **[^](#cite_ref-13)** ["Is Shape Up just a nice theory?"](https://www.curiouslab.io/blog/is-shape-up-just-a-nice-theory). *Curious Lab*. Retrieved September 12, 2022.
14. **[^](#cite_ref-ieeeswbdd_14-0)** Lübke, Daniel; van Lessen, Tammo (2016). "Modeling Test Cases in BPMN for Behavior-Driven Development". *IEEE Software*. **33** (5): 15–21. [doi](/wiki/Doi_(identifier) "Doi (identifier)"):[10.1109/MS.2016.117](https://doi.org/10.1109%2FMS.2016.117). [S2CID](/wiki/S2CID_(identifier) "S2CID (identifier)") [14539297](https://api.semanticscholar.org/CorpusID:14539297).

External links[[edit](/w/index.php?title=Software_development_process&action=edit&section=16 "Edit section: External links")]
-----------------------------------------------------------------------------------------------------------------------------




![](//upload.wikimedia.org/wikipedia/en/thumb/4/4a/Commons-logo.svg/30px-Commons-logo.svg.png)
Wikimedia Commons has media related to [Software development methodology](https://commons.wikimedia.org/wiki/Category:Software_development_methodology "commons:Category:Software development methodology").

* [Selecting a development approach](http://www.cms.gov/Research-Statistics-Data-and-Systems/CMS-Information-Technology/XLC/Downloads/SelectingDevelopmentApproach.pdf) at cms.hhs.gov.
* Gerhard Fischer, ["The Software Technology of the 21st Century: From Software Reuse to Collaborative Software Design"](http://l3d.cs.colorado.edu/~gerhard/papers/isfst2001.pdf), 2001




| * [v](/wiki/Template:Software_engineering "Template:Software engineering") * [t](/wiki/Template_talk:Software_engineering "Template talk:Software engineering") * [e](/wiki/Special:EditPage/Template:Software_engineering "Special:EditPage/Template:Software engineering") [Software engineering](/wiki/Software_engineering "Software engineering") | |
| --- | --- |
| Fields | * [Computer programming](/wiki/Computer_programming "Computer programming") * [DevOps](/wiki/DevOps "DevOps") * [Empirical software engineering](/wiki/Empirical_software_engineering "Empirical software engineering") * [Experimental software engineering](/wiki/Experimental_software_engineering "Experimental software engineering") * [Formal methods](/wiki/Formal_methods "Formal methods") * [Requirements engineering](/wiki/Requirements_engineering "Requirements engineering") * [Search-based software engineering](/wiki/Search-based_software_engineering "Search-based software engineering") * [Site reliability engineering](/wiki/Site_reliability_engineering "Site reliability engineering") * [Social software engineering](/wiki/Social_software_engineering "Social software engineering") * [Software deployment](/wiki/Software_deployment "Software deployment") * [Software design](/wiki/Software_design "Software design") * [Software maintenance](/wiki/Software_maintenance "Software maintenance") * [Software testing](/wiki/Software_testing "Software testing") * [Systems analysis](/wiki/Systems_analysis "Systems analysis") |
| Concepts | * [Abstraction](/wiki/Abstraction_(computer_science) "Abstraction (computer science)") * [Component-based software engineering](/wiki/Component-based_software_engineering "Component-based software engineering") * [Software compatibility](/wiki/Computer_compatibility "Computer compatibility") 	+ [Backward compatibility](/wiki/Backward_compatibility "Backward compatibility") 	+ [Compatibility layer](/wiki/Compatibility_layer "Compatibility layer") 	+ [Compatibility mode](/wiki/Compatibility_mode "Compatibility mode") 	+ [Forward compatibility](/wiki/Forward_compatibility "Forward compatibility") 	+ [Software incompatibility](/wiki/Software_incompatibility "Software incompatibility") * [Data modeling](/wiki/Data_modeling "Data modeling") * [Enterprise architecture](/wiki/Enterprise_architecture "Enterprise architecture") * [Functional specification](/wiki/Functional_specification "Functional specification") * [Modeling language](/wiki/Modeling_language "Modeling language") * [Programming paradigm](/wiki/Programming_paradigm "Programming paradigm") * [Software](/wiki/Software "Software") * [Software archaeology](/wiki/Software_archaeology "Software archaeology") * [Software architecture](/wiki/Software_architecture "Software architecture") * [Software configuration management](/wiki/Software_configuration_management "Software configuration management") * Software development process/methodology * [Software quality](/wiki/Software_quality "Software quality") * [Software quality assurance](/wiki/Software_quality_assurance "Software quality assurance") * [Software verification and validation](/wiki/Software_verification_and_validation "Software verification and validation") * [Software system](/wiki/Software_system "Software system") * [Structured analysis](/wiki/Structured_analysis "Structured analysis") 	+ [Essential analysis](/wiki/Essential_systems_analysis "Essential systems analysis") * [CI/CD](/wiki/CI/CD "CI/CD") |
| Orientations | * [Agile](/wiki/Agile_software_development "Agile software development") * [Aspect-oriented](/wiki/Aspect-oriented_programming "Aspect-oriented programming") * [Object orientation](/wiki/Object-oriented_programming "Object-oriented programming") * [Ontology](/wiki/Ontology_(information_science) "Ontology (information science)") * [Service orientation](/wiki/Service-oriented_architecture "Service-oriented architecture") * [SDLC](/wiki/Systems_development_life_cycle "Systems development life cycle") |
| Models | | Developmental | * [Agile](/wiki/Agile_software_development "Agile software development") * [EUP](/wiki/Enterprise_unified_process "Enterprise unified process") * [Executable UML](/wiki/Executable_UML "Executable UML") * [Incremental model](/wiki/Incremental_build_model "Incremental build model") * [Iterative model](/wiki/Iterative_and_incremental_development "Iterative and incremental development") * [Prototype model](/wiki/Software_prototyping "Software prototyping") * [RAD](/wiki/Rapid_application_development "Rapid application development") * [UP](/wiki/Unified_Process "Unified Process") * [Scrum](/wiki/Scrum_(software_development) "Scrum (software development)") * [Spiral model](/wiki/Spiral_model "Spiral model") * [V-model](/wiki/V-model_(software_development) "V-model (software development)") * [Waterfall model](/wiki/Waterfall_model "Waterfall model") * [XP](/wiki/Extreme_programming "Extreme programming") * [Model-driven engineering](/wiki/Model-driven_engineering "Model-driven engineering") * [Round-trip engineering](/wiki/Round-trip_engineering "Round-trip engineering") | | --- | --- | | Other | * [SPICE](/wiki/ISO/IEC_15504 "ISO/IEC 15504") * [CMMI](/wiki/Capability_Maturity_Model_Integration "Capability Maturity Model Integration") * [Data model](/wiki/Data_model "Data model") * [ER model](/wiki/Entity%E2%80%93relationship_model "Entity–relationship model") * [Function model](/wiki/Function_model "Function model") * [Information model](/wiki/Information_model "Information model") * [Metamodeling](/wiki/Metamodeling "Metamodeling") * [Object model](/wiki/Object_model "Object model") * [Systems model](/wiki/Systems_modeling "Systems modeling") * [View model](/wiki/View_model "View model") | | Languages | * [IDEF](/wiki/IDEF "IDEF") * [UML](/wiki/Unified_Modeling_Language "Unified Modeling Language") * [USL](/wiki/Universal_Systems_Language "Universal Systems Language") * [SysML](/wiki/Systems_modeling_language "Systems modeling language") | |
| Related fields | * [Computer science](/wiki/Computer_science "Computer science") * [Computer engineering](/wiki/Computer_engineering "Computer engineering") * [Information science](/wiki/Information_science "Information science") * [Project management](/wiki/Project_management "Project management") * [Risk management](/wiki/Risk_management "Risk management") * [Systems engineering](/wiki/Systems_engineering "Systems engineering") |
| * [Commons](https://commons.wikimedia.org/wiki/Category:Software_engineering "commons:Category:Software engineering") * [Category](/wiki/Category:Software_engineering "Category:Software engineering") | |





![](https://login.wikimedia.org/wiki/Special:CentralAutoLogin/start?type=1x1)
Retrieved from "<https://en.wikipedia.org/w/index.php?title=Software_development_process&oldid=1226674357>"
[Categories](/wiki/Help:Category "Help:Category"): * [Software development process](/wiki/Category:Software_development_process "Category:Software development process")
* [Methodology](/wiki/Category:Methodology "Category:Methodology")
* [Software engineering](/wiki/Category:Software_engineering "Category:Software engineering")
Hidden categories: * [CS1 German-language sources (de)](/wiki/Category:CS1_German-language_sources_(de) "Category:CS1 German-language sources (de)")
* [Articles with short description](/wiki/Category:Articles_with_short_description "Category:Articles with short description")
* [Short description matches Wikidata](/wiki/Category:Short_description_matches_Wikidata "Category:Short description matches Wikidata")
* [Use mdy dates from December 2023](/wiki/Category:Use_mdy_dates_from_December_2023 "Category:Use mdy dates from December 2023")
* [Articles needing additional references from December 2010](/wiki/Category:Articles_needing_additional_references_from_December_2010 "Category:Articles needing additional references from December 2010")
* [All articles needing additional references](/wiki/Category:All_articles_needing_additional_references "Category:All articles needing additional references")
* [Use American English from April 2022](/wiki/Category:Use_American_English_from_April_2022 "Category:Use American English from April 2022")
* [All Wikipedia articles written in American English](/wiki/Category:All_Wikipedia_articles_written_in_American_English "Category:All Wikipedia articles written in American English")
* [All articles with unsourced statements](/wiki/Category:All_articles_with_unsourced_statements "Category:All articles with unsourced statements")
* [Articles with unsourced statements from September 2020](/wiki/Category:Articles_with_unsourced_statements_from_September_2020 "Category:Articles with unsourced statements from September 2020")
* [All articles with specifically marked weasel-worded phrases](/wiki/Category:All_articles_with_specifically_marked_weasel-worded_phrases "Category:All articles with specifically marked weasel-worded phrases")
* [Articles with specifically marked weasel-worded phrases from January 2021](/wiki/Category:Articles_with_specifically_marked_weasel-worded_phrases_from_January_2021 "Category:Articles with specifically marked weasel-worded phrases from January 2021")
* [Commons category link is on Wikidata](/wiki/Category:Commons_category_link_is_on_Wikidata "Category:Commons category link is on Wikidata")

